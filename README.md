### Тестовая задача

Требования:
1. Требуется разработать механизм асинхронной обработки HTTP запросов
2. Требуется использовать стек NodeJS, RabbitMQ
3. Требуется оформить в виде репозитория на Github
4. Требуется приложить инструкцию по локальному развертыванию проекта
5. Требуется реализовать логирование для целей отладки и мониторинга
6. Требуется разработать микросервис М1 для обработки входящих HTTP запросов
7. Требуется разработать микросервис М2 для обработки заданий из RabbitMQ

Алгоритм работы:
• Получаем HTTP запрос на уровне микросервиса М1.
• Транслируем HTTP запрос в очередь RabbitMQ. Запрос трансформируется в задание.
• Обрабатываем задание микросервисом М2 из очереди RabbitMQ.
• Помещаем результат обработки задания в RabbitMQ.
• Возвращаем результат HTTP запроса как результат выполнения задания из RabbitMQ.


### Логика работы

В сервис `producer` поступает запрос. Он кладёт задачу в очередь и в редис (наверное, можно и без рэббита).
Сервис `consumer` подхватывает задачу из рэббита, выполняет, и кладёт результат выполнения в редис.
В сервисе `producer` есть отдельный эндпоинт для получения результатов по таске.

### Запуск

`docker compose up -d` в корне проекта


### Комментарии

Ждать с отправкой ответа, пока мы не получим из очереди результат для нужной нам таски считаю нецелесообразно.
Выгоднее будет использовать KV базу и класть результаты тасок туда. По-хорошему ещё бы прикрутить вебсокеты,
чтобы клиент мог подписаться на редис и отслеживать состояние таски в реальном времени.
Вместо редиса можно использовать `etcd` для бОльшей консистентности, при необходимости.